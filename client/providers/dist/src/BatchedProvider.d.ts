/// <reference types="node" />
import { BigNumberish } from "@ethersproject/bignumber";
import { Provider, TransactionRequest, BlockTag } from "@ethersproject/abstract-provider";
import { BaseProvider } from "@ethersproject/providers";
import { BytesLike } from "@ethersproject/bytes";
import { Contract } from "@ethersproject/contracts";
import { Deferrable } from "@ethersproject/properties";
declare class MultiCaller extends Contract {
    performMultiple(calls: {
        to: string;
        data: BytesLike;
    }[], overrides?: {
        from?: string;
        blockTag?: BlockTag;
    }): Promise<string[]>;
}
declare type ResolvedTransactionRequest = {
    to?: string;
    from?: string;
    nonce?: BigNumberish;
    gasLimit?: BigNumberish;
    gasPrice?: BigNumberish;
    data?: BytesLike;
    value?: BigNumberish;
    chainId?: number;
};
declare type CallRequest = {
    to: string;
    data: BytesLike;
};
declare type BatchedCalls = {
    calls: CallRequest[];
    callbacks: [(resolveValue: string) => void, (rejectReason: any) => void][];
    from?: string;
    blockTag?: BlockTag;
};
export interface BatchedProvider extends BaseProvider {
    batchingDelayMs: number;
    chainId: number;
}
export declare const isBatchedProvider: (provider: Provider) => provider is BatchedProvider;
export declare const Batched: <T extends new (...args: any[]) => BaseProvider>(Base: T) => {
    new (...args: any[]): {
        batchingDelayMs: number;
        _chainId: number;
        _multiCaller?: MultiCaller | undefined;
        _timeoutId: any;
        _batched: BatchedCalls;
        _numberOfBatchedCalls: number;
        _numberOfActualCalls: number;
        _timeOfLastRatioCheck?: number | undefined;
        chainId: number;
        _dispatchCalls(): Promise<void>;
        _enqueueCall(call: CallRequest): Promise<string>;
        _alreadyBatchedCallsConflictWith(request: ResolvedTransactionRequest, blockTag?: string | number | undefined): boolean;
        call(request: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        waitForTransaction(transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<import("@ethersproject/bignumber").BigNumber>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<import("@ethersproject/bignumber").BigNumber>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | import("@ethersproject/bignumber").BigNumber | import("@ethersproject/bytes").Bytes | Promise<BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined): import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/bignumber").BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getTransaction(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver>;
        _getResolver(name: string): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string>;
        lookupAddress(address: string | Promise<string>): Promise<string>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean): any;
        on(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        once(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        emit(eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): import("@ethersproject/abstract-provider").Listener[];
        off(eventName: import("@ethersproject/abstract-provider").EventType, listener?: import("@ethersproject/abstract-provider").Listener | undefined): any;
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        addListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        removeListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        readonly _isProvider: boolean;
    };
} & T;
export declare const BatchedWebSocketAugmentedWeb3Provider: {
    new (...args: any[]): {
        batchingDelayMs: number;
        _chainId: number;
        _multiCaller?: MultiCaller | undefined;
        _timeoutId: any;
        _batched: BatchedCalls;
        _numberOfBatchedCalls: number;
        _numberOfActualCalls: number;
        _timeOfLastRatioCheck?: number | undefined;
        chainId: number;
        _dispatchCalls(): Promise<void>;
        _enqueueCall(call: CallRequest): Promise<string>;
        _alreadyBatchedCallsConflictWith(request: ResolvedTransactionRequest, blockTag?: string | number | undefined): boolean;
        call(request: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        waitForTransaction(transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<import("@ethersproject/bignumber").BigNumber>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<import("@ethersproject/bignumber").BigNumber>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | import("@ethersproject/bignumber").BigNumber | import("@ethersproject/bytes").Bytes | Promise<BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined): import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/bignumber").BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getTransaction(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver>;
        _getResolver(name: string): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string>;
        lookupAddress(address: string | Promise<string>): Promise<string>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean): any;
        on(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        once(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        emit(eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): import("@ethersproject/abstract-provider").Listener[];
        off(eventName: import("@ethersproject/abstract-provider").EventType, listener?: import("@ethersproject/abstract-provider").Listener | undefined): any;
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        addListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        removeListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        readonly _isProvider: boolean;
    };
} & {
    new (...args: any[]): {
        _wsProvider?: import("./WebSocketProvider").WebSocketProvider | undefined;
        _wsParams?: [string, import("@ethersproject/providers").Networkish] | undefined;
        _reconnectTimerId: any;
        _seenBlock: number;
        _blockListenerScheduled: boolean;
        readonly _blockListeners: Set<(blockNumber: number) => void>;
        readonly _blockListener: (blockNumber: number) => void;
        openWebSocket(url: string, network: import("@ethersproject/providers").Networkish): void;
        _onWebSocketClose(): void;
        closeWebSocket(): void;
        _switchover(): void;
        _onBlock(blockNumber: number): void;
        _retrySeenBlock<T>(perform: () => Promise<T>, startingBlock: number): Promise<T>;
        call(transaction: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<import("@ethersproject/bignumber").BigNumber>;
        _startBlockEvents(): void;
        _stopBlockEvents(): void;
        on(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        _addBlockListener(listener: (blockNumber: number) => void): any;
        once(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        off(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        _removeBlockListener(listener: (blockNumber: number) => void): any;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        _blockContainsTx(blockNumber: number, txHash: string): Promise<boolean>;
        _getTransactionReceiptFromLatest(txHash: string | Promise<string>, latestBlock?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt | null>;
        waitForTransaction(txHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<import("@ethersproject/bignumber").BigNumber>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | import("@ethersproject/bignumber").BigNumber | import("@ethersproject/bytes").Bytes | Promise<BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined): import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/bignumber").BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getTransaction(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver>;
        _getResolver(name: string): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string>;
        lookupAddress(address: string | Promise<string>): Promise<string>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean): any;
        emit(eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): import("@ethersproject/abstract-provider").Listener[];
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        addListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        removeListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        readonly _isProvider: boolean;
    };
} & typeof import("@ethersproject/providers").Web3Provider;
export {};
//# sourceMappingURL=BatchedProvider.d.ts.map